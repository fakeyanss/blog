<!DOCTYPE html>
<html lang="zh-Hans">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="è¿™æ˜¯ä¸€ç¯‡åˆå­¦Hadoopæ—¶åº”è¯¥æµè§ˆçš„åšå®¢ï¼Œå—18å¹´å®ä¹ æ—¶çš„mentoræ¨èï¼Œæˆ‘è¯»äº†Understanding Hadoop Clusters and the Networkä¸€æ–‡ï¼Œå¹¶åœ¨è¿™é‡Œç¿»è¯‘ä¸€éã€‚">
    

    <!--Author-->
    
        <meta name="author" content="fakeyanss">
    

    <!-- Title -->
    
    <title>Hadoopå…¥é—¨ | Yet Another Possibility</title>

    <!-- Bootstrap Core CSS -->
    <link href="//cdn.jsdelivr.net/npm/bootstrap@3.3.6/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/blog/css/style.css">


    <!-- Custom Fonts -->
    <link href="//cdn.jsdelivr.net/npm/font-awesome@4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Noto+Serif:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- jQuery -->
    <script src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script>
    <!-- Bootstrap -->
    <script src="//cdn.jsdelivr.net/npm/bootstrap@3.3.6/dist/js/bootstrap.min.js"></script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
<meta name="generator" content="Hexo 7.0.0-rc1"></head>


<body>

    <!-- Content -->
    <section class="article-container">
    <!-- Back Home -->
    <a class="nav-back" href="/blog/">
    <i class="fa fa-puzzle-piece"></i>
</a>

        <!-- Page Header -->
        <header class="intro-header">
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                        <div class="post-heading">
                            <h1>
                                Hadoopå…¥é—¨
                            </h1>
                        </div>
                    </div>
                </div>
            </div>
        </header>

        <!-- Post Content -->
        <article>
            <div class="container">
                <div class="row">
                    <!-- Post Main Content -->
                    <div class="post-content col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                        <p>è¿™æ˜¯ä¸€ç¯‡åˆå­¦Hadoopæ—¶åº”è¯¥æµè§ˆçš„åšå®¢ï¼Œå—18å¹´å®ä¹ æ—¶çš„mentoræ¨èï¼Œæˆ‘è¯»äº†Understanding Hadoop Clusters and the Networkä¸€æ–‡ï¼Œå¹¶åœ¨è¿™é‡Œç¿»è¯‘ä¸€éã€‚</p>
<span id="more"></span>
<hr>
<h1 id="Understanding-Hadoop-Clusters-and-the-Network"><a href="#Understanding-Hadoop-Clusters-and-the-Network" class="headerlink" title="Understanding Hadoop Clusters and the Network"></a>Understanding Hadoop Clusters and the Network</h1><p>Author: Brad Hedlund<br><br>Link: <a href="http://bradhedlund.com/2011/09/10/understanding-hadoop-clusters-and-the-network/">original text</a><br><br>Translator: Yanss</p>
<p>This article is Part 1 in series that will take a closer look at the architecture and methods of a Hadoop cluster, and how it relates to the network and server infrastructure. The content presented here is largely based on academic work and conversations Iâ€™ve had with customers running real production clusters. If you run production Hadoop clusters in your data center, Iâ€™m hoping youâ€™ll provide your valuable insight in the comments below. Subsequent articles to this will cover the server and network architecture options in closer detail. Before we do that though, lets start by learning some of the basics about how a Hadoop cluster works. OK, letâ€™s get started!</p>
<p>æœ¬æ–‡æ˜¯ç³»åˆ—çš„ç¬¬1éƒ¨åˆ†ï¼Œå°†å¸¦ä½ è¯¦ç»†äº†è§£Hadoopé›†ç¾¤çš„æ¶æ„å’Œæ–¹æ³•ï¼Œä»¥åŠå®ƒå¦‚ä½•å°†ç½‘ç»œå’ŒæœåŠ¡å™¨åŸºç¡€è®¾æ–½ç›¸å…³è”ã€‚è¿™é‡Œä»‹ç»çš„å†…å®¹ä¸»è¦æ˜¯åŸºäºå­¦æœ¯ç ”ç©¶å’Œæˆ‘ä¸åœ¨å®é™…äº§å“ä¸­è¿è¡Œé›†ç¾¤çš„å®¢æˆ·çš„äº¤æµã€‚å¦‚æœä½ åœ¨ä½ çš„æ•°æ®ä¸­å¿ƒä¸­è¿è¡ŒHadoopé›†ç¾¤ç”Ÿäº§ï¼Œæˆ‘æœŸå¾…ä½ åœ¨ä¸‹é¢çš„è¯„è®ºä¸­æä¾›æœ‰ä»·å€¼çš„è§è§£ã€‚æ¥ä¸‹æ¥çš„æ–‡ç« å°†ä¼šåŒ…å«æœåŠ¡å™¨å’Œç½‘ç»œç»“æ„çš„è¯¦ç»†ç»†èŠ‚ã€‚ç„¶è€Œåœ¨æ­¤ä¹‹å‰ï¼Œè®©æˆ‘äº†è§£ä¸€äº›Hadoopé›†ç¾¤å·¥ä½œçš„åŸºç¡€ã€‚<br><img src="https://foreti.me/imgplace/2019/Hadoop-Server-Roles.png" alt="Hadoop-Server-Roles"></p>
<p>The three major categories of machine roles in a Hadoop deployment are Client machines, Masters nodes, and Slave nodes. The Master nodes oversee the two key functional pieces that make up Hadoop: storing lots of data (HDFS), and running parallel computations on all that data (Map Reduce). The Name Node oversees and coordinates the data storage function (HDFS), while the Job Tracker oversees and coordinates the parallel processing of data using Map Reduce. Slave Nodes make up the vast majority of machines and do all the dirty work of storing the data and running the computations. Each slave runs both a Data Node and Task Tracker daemon that communicate with and receive instructions from their master nodes. The Task Tracker daemon is a slave to the Job Tracker, the Data Node daemon a slave to the Name Node.</p>
<p>Hadoopéƒ¨ç½²çš„ä¸‰ä¸ªä¸»è¦åˆ†ç±»åˆ†åˆ«æ˜¯Client machinesã€Masters nodeså’ŒSlave nodesã€‚ä¸»èŠ‚ç‚¹ç›‘ç£ä¸¤ä¸ªé‡è¦çš„åŠŸèƒ½å—å½¢æˆHadoopï¼šå­˜å‚¨å¤§é‡æ•°æ®(HDFS)ï¼Œåœ¨æ‰€æœ‰æ•°æ®ä¸Šå¹¶è¡Œè®¡ç®—(Map Reduce)ã€‚Name Nodeç›‘ç£åè°ƒæ•°æ®å­˜å‚¨åŠŸèƒ½(HDFS)ï¼ŒåŒæ—¶Job Trackerç›‘ç£åè°ƒä½¿ç”¨Map Reduceè¿›è¡Œæ•°æ®çš„å¹¶è¡Œå¤„ç†ã€‚Slave Nodeså½¢æˆå¤§å¤šæ•°çš„æœºæ„ï¼Œåšç€æ‰€æœ‰çš„å­˜å‚¨æ•°æ®å’Œè¿è¡Œè®¡ç®—çš„è„æ´»ã€‚æ¯ä¸ªslaveåŒæ—¶è¿è¡Œç€Data Nodeå’ŒTask Trackerçš„åå°ç¨‹åºâ€”â€”ç”¨ä»¥ä¼ é€’å’Œæ¥æ”¶æ¥è‡ªä»–ä»¬çš„master nodesçš„å‘½ä»¤ã€‚Task Trackeråå°ç¨‹åºæ˜¯Job Trackerçš„slaveï¼ŒData nodeåå°ç¨‹åºæ˜¯Name Nodeçš„slaveã€‚</p>
<p>Client machines have Hadoop installed with all the cluster settings, but are neither a Master or a Slave. Instead, the role of the Client machine is to load data into the cluster, submit Map Reduce jobs describing how that data should be processed, and then retrieve or view the results of the job when its finished. In smaller clusters (~40 nodes) you may have a single physical server playing multiple roles, such as both Job Tracker and Name Node. With medium to large clusters you will often have each role operating on a single server machine.</p>
<p>Client machinesçš„Hadoopå®‰è£…äº†æ‰€æœ‰çš„é›†ç¾¤è®¾ç½®ï¼Œä½†ä¸åŒ…å«Masteræˆ–Slaveã€‚ç›¸åº”çš„ï¼ŒClient machineçš„ä½œç”¨æ˜¯åŠ è½½æ•°æ®åˆ°é›†ç¾¤ï¼Œæäº¤Map Reduceå·¥ä½œï¼Œæè¿°æ•°æ®åº”è¯¥æ€ä¹ˆå¤„ç†ï¼Œç„¶ååœ¨å…¬ä¼—å®Œæˆæ—¶å–å›æˆ–æŸ¥çœ‹ç»“æœã€‚åœ¨å°ä¸€äº›çš„é›†ç¾¤ï¼ˆçº¦40ä¸ªèŠ‚ç‚¹ï¼‰ä¸­ï¼Œä½ å¯èƒ½åªæœ‰ä¸€ä¸ªå®ä½“æœåŠ¡å™¨è¿è¡Œå¤šä»»åŠ¡ï¼Œä¾‹å¦‚Job Trackerå’ŒName Nodeä¸€æ ·ã€‚åœ¨ä¸­å¤§å‹é›†ç¾¤ä½ å¯èƒ½ä¼šåœ¨å•ä¸ªæœåŠ¡å™¨ä¸­è¿›è¡Œå•ä¸ªä»»åŠ¡è¿è½¬ã€‚</p>
<p>In real production clusters there is no server virtualization, no hypervisor layer. That would only amount to unnecessary overhead impeding performance. Hadoop runs best on Linux machines, working directly with the underlying hardware. That said, Hadoop does work in a virtual machine. Thatâ€™s a great way to learn and get Hadoop up and running fast and cheap. I have a 6-node cluster up and running in VMware Workstation on my Windows 7 laptop.</p>
<p>åœ¨å®é™…ç”Ÿäº§é›†ç¾¤ä¸­æ²¡æœ‰æœåŠ¡å™¨è™šæ‹ŸåŒ–ï¼Œæ²¡æœ‰è™šæ‹Ÿæœºç›‘è§†å™¨ã€‚é‚£åªä¼šäº§ç”Ÿå¤§é‡ä¸å¿…è¦çš„æ€§èƒ½å¼€æ”¯ã€‚Hadoopåœ¨Linuxæœºå™¨ä¸Šè¿è¡Œå¾—æœ€å¥½ï¼Œç›´æ¥åœ¨åº•å±‚ç¡¬ä»¶ä¸Šå·¥ä½œã€‚ä¹Ÿå°±æ˜¯è¯´ï¼ŒHadoopåœ¨è™šæ‹Ÿæœºä¸Šå·¥ä½œã€‚é‚£æ˜¯äº†è§£å’Œæ­å»ºHadoopçš„å¥½åŠæ³•ï¼Œå¹¶ä¸”è¿è¡Œçš„åˆå¿«åˆä¾¿å®œã€‚æˆ‘æœ‰ä¸€ä¸ª6èŠ‚ç‚¹çš„é›†ç¾¤ï¼Œè¿è¡Œåœ¨æˆ‘çš„Windows 7ç¬”è®°æœ¬çš„VMwareå·¥ä½œå°ä¸Šã€‚</p>
<hr>
<p><img src="https://foreti.me/imgplace/2019/Hadoop-Cluster.png" alt="Hadoop-Cluster"></p>
<p>This is the typical architecture of a Hadoop cluster. You will have rack servers (not blades) populated in racks connected to a top of rack switch usually with 1 or 2 GE boned links. 10GE nodes are uncommon but gaining interest as machines continue to get more dense with CPU cores and disk drives. The rack switch has uplinks connected to another tier of switches connecting all the other racks with uniform bandwidth, forming the cluster. The majority of the servers will be Slave nodes with lots of local disk storage and moderate amounts of CPU and DRAM. Some of the machines will be Master nodes that might have a slightly different configuration favoring more DRAM and CPU, less local storage. In this post, we are not going to discuss various detailed network design options. Letâ€™s save that for another discussion (stay tuned). First, lets understand how this application worksâ€¦</p>
<p>è¿™æ˜¯ä¸€ä¸ªHadoopé›†ç¾¤çš„å…¸å‹ç»“æ„ã€‚ä½ å°†ä½¿ç”¨æœºæ¶æœåŠ¡å™¨(ä¸æ˜¯åˆ€é”‹æœåŠ¡å™¨)ï¼Œæ­å»ºåœ¨æœºæ¶ä¸­ï¼Œè¿æ¥ä¸€ä¸ªé¡¶éƒ¨æœºæ¶å¼€å…³ï¼Œé€šå¸¸ä½¿ç”¨1æˆ–2 GE(Gigabit Ethernetåƒå…†ä»¥å¤ªç½‘)ã€‚10 GEèŠ‚ç‚¹æ˜¯ä¸å¸¸æœ‰çš„ï¼Œä½†å½“æœºå™¨ä½¿ç”¨CPUæ ¸å¿ƒå’Œç£ç›˜é©±åŠ¨è·å–æ›´å¤§çš„å¯†åº¦æ—¶æ”¶ç›Šæ›´å¤šã€‚æœºæ¶å¼€å…³ä¸Šè¡Œä¼ è¾“è¢«è¿æ¥åˆ°è¿æ¥æ‰€æœ‰å…¶ä»–ç›¸åŒå¸¦å®½æœºæ¶çš„å¦ä¸€å±‚å¼€å…³ï¼Œæ„æˆé›†ç¾¤ã€‚å¤§å¤šæ•°æœåŠ¡å™¨æ˜¯Slave nodesï¼Œä½¿ç”¨å¤§é‡çš„æœ¬åœ°ç£ç›˜å­˜å‚¨å’Œä¸­é‡çš„CPUå’ŒDRAMã€‚ä¸€äº›æœºå™¨æ˜¯Master nodesï¼Œå¯èƒ½æœ‰è½»å¾®ä¸åŒçš„é…ç½®ï¼Œä½¿ç”¨æ›´å¤šçš„DRAMå’ŒCPUï¼Œè¾ƒå°‘çš„æœ¬åœ°å­˜å‚¨ã€‚åœ¨è¿™ç‰‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬ä¸è®¨è®ºè®¸å¤šè¯¦ç»†çš„ç½‘ç»œè®¾è®¡é€‰æ‹©ï¼Œè®©æˆ‘ä»¬å°†å®ƒä¿ç•™åˆ°å¦ä¸€ä¸ªè®¨è®º(åœ¨è°ƒè¯•ä¸­)ä¸­ã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬ç†è§£è¿™ä¸ªåº”ç”¨æ€ä¹ˆå·¥ä½œçš„ã€‚</p>
<hr>
<p><img src="https://foreti.me/imgplace/2019/Workflow.png" alt="Workflow"></p>
<p>Why did Hadoop come to exist? What problem does it solve? Simply put, businesses and governments have a tremendous amount of data that needs to be analyzed and processed very quickly. If I can chop that huge chunk of data into small chunks and spread it out over many machines, and have all those machines processes their portion of the data in parallel â€“ I can get answers extremely fast â€“ and that, in a nutshell, is what Hadoop does. In our simple example, weâ€™ll have a huge data file containing emails sent to the customer service department. I want a quick snapshot to see how many times the word â€œRefundâ€ was typed by my customers. This might help me to anticipate the demand on our returns and exchanges department, and staff it appropriately. Itâ€™s a simple word count exercise. The Client will load the data into the cluster (File.txt), submit a job describing how to analyze that data (word count), the cluster will store the results in a new file (Results.txt), and the Client will read the results file.</p>
<p>Hadoopä¸ºä½•è¯ç”Ÿï¼Ÿå®ƒè§£å†³äº†ä»€ä¹ˆé—®é¢˜ï¼Ÿç®€è¨€ä¹‹ï¼Œå•†ä¸šå’Œæ”¿åºœæœ‰ä¸€ä¸ªæå¤§é‡çš„æ•°æ®éœ€è¦éå¸¸å¿«åœ°åˆ†æå’Œå¤„ç†ã€‚å¦‚æœæˆ‘å¯ä»¥åˆ†ç¦»è¿™ä¸ªå·¨å¤§çš„æ•°æ®åˆ°å¾ˆå¤šå°çš„éƒ¨åˆ†ï¼Œé“ºå¼€åˆ°å¤§é‡çš„æœºå™¨ä¸­ï¼Œè®©è¿™äº›æœºå™¨å¹¶è¡Œå¤„ç†å®ƒä»¬å„è‡ªçš„é‚£ä¸€éƒ¨åˆ†â€”â€”æˆ‘å°±å¯ä»¥æå¿«çš„è·å–ç»“æœâ€”â€”è¿™å°±æ˜¯Hadoopåšçš„äº‹æƒ…ã€‚åœ¨æˆ‘ä»¬çš„ç®€å•ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å°†ç”¨ä¸€ä¸ªå·¨å¤§çš„æ•°æ®æ–‡ä»¶ï¼Œå®ƒåŒ…å«äº†å‘é€åˆ°å®¢æˆ·æœåŠ¡éƒ¨é—¨çš„é‚®ä»¶ã€‚æˆ‘æƒ³è¦ä¸€ä¸ªæ•°æ®å¿«ç…§ï¼Œæ¥æŸ¥çœ‹å•è¯â€œRefundâ€è¢«å®¢æˆ·è¾“å…¥äº†å¤šå°‘æ¬¡ã€‚è¿™å°†æœ‰åŠ©äºæˆ‘é¢„æµ‹é€€è¿˜å’Œäº¤æ¢éƒ¨é—¨çš„éœ€æ±‚ï¼Œå¹¶ä¸”åˆç†åœ°å®‰æ’èŒå‘˜ã€‚è¿™æ˜¯ä¸€ä¸ªç®€å•çš„è¯æ¡è®¡æ•°è®­ç»ƒã€‚Clientså°†ä¼šåŠ è½½æ•°æ®åˆ°é›†ç¾¤(File.txt)ï¼Œæäº¤ä¸€ä¸ªå·¥ä½œæè¿°ï¼Œå¦‚ä½•åˆ†ææ•°æ®(å•è¯è®¡æ•°)ï¼Œé›†ç¾¤ä¼šå­˜å‚¨ç»“æœåˆ°ä¸€ä¸ªæ–°çš„æ–‡ä»¶(Results.txt)ï¼Œç„¶åClientsä¼šè¯»å–ç»“æœæ–‡ä»¶ã€‚</p>
<hr>
<p><img src="https://foreti.me/imgplace/2019/Writing-Files-to-HDFS.png" alt="Writing-Files-to-HDFS"></p>
<p>Your Hadoop cluster is useless until it has data, so weâ€™ll begin by loading our huge File.txt into the cluster for processing. The goal here is fast parallel processing of lots of data. To accomplish that I need as many machines as possible working on this data all at once. To that end, the Client is going to break the data file into smaller â€œBlocksâ€, and place those blocks on different machines throughout the cluster. The more blocks I have, the more machines that will be able to work on this data in parallel. At the same time, these machines may be prone to failure, so I want to insure that every block of data is on multiple machines at once to avoid data loss. So each block will be replicated in the cluster as its loaded. The standard setting for Hadoop is to have (3) copies of each block in the cluster. This can be configured with the <strong>dfs.replication</strong> parameter in the file <strong>hdfs-site.xml</strong>.</p>
<p>ä½ çš„Hadoopé›†ç¾¤ç›´åˆ°æœ‰æ•°æ®æ‰æœ‰ç”¨ï¼Œæ‰€ä»¥æˆ‘ä»¬å¼€å§‹äºåŠ è½½è¶…å¤§çš„File.txtåˆ°é›†ç¾¤ä¸­å¤„ç†ã€‚è¿™é‡Œçš„ç›®æ ‡æ˜¯å¿«é€Ÿå¹¶è¡Œå¤„ç†å¤§é‡æ•°æ®ã€‚ä¸ºæ­¤æˆ‘éœ€è¦å°½å¯èƒ½å¤šçš„æœºå™¨åŒæ—¶å¤„ç†è¿™äº›æ•°æ®ã€‚åœ¨é‚£ç»“æŸåï¼ŒClientå°†ä¼šæ‰“æ–­è¿™ä¸ªæ•°æ®æ–‡ä»¶ä¸ºè®¸å¤šå°çš„å—ï¼Œå°†è¿™äº›å—æ”¾åˆ°éåŠé›†ç¾¤çš„ä¸åŒçš„æœºå™¨ä¸Šã€‚åˆ†æˆçš„å—è¶Šå¤šï¼Œèƒ½å¹¶è¡Œå·¥ä½œçš„æœºå™¨å°±è¶Šå¤šã€‚åœ¨åŒä¸€æ—¶é—´ï¼Œè¿™äº›æœºå™¨å¯èƒ½å®¹æ˜“å¤±è´¥ï¼Œæ‰€ä»¥ä¸ºäº†é¿å…æ•°æ®ä¸¢å¤±ï¼Œæˆ‘ä¼šç¡®ä¿¡æ¯ä¸ªæ•°æ®å—åœ¨å¤šå°æœºå™¨ä¸Šå­˜åœ¨ã€‚æ‰€ä»¥æ¯ä¸ªå—ä¼šåœ¨åŠ è½½åˆ°é›†ç¾¤æ—¶å¤åˆ¶ã€‚Hadoopçš„æ ‡å‡†è®¾ç½®æ˜¯é›†ç¾¤ä¸­æ¯ä¸ªå—æœ‰3ä¸ªå¤åˆ¶ã€‚è¿™ä¸ªå¯ä»¥åœ¨hdfs-site.xmlæ–‡ä»¶çš„dfs.replicationå‚æ•°ä¸­è®¾ç½®ã€‚</p>
<p>The Client breaks File.txt into (3) Blocks. For each block, the Client consults the Name Node (usually TCP 9000) and receives a list of (3) Data Nodes that should have a copy of this block. The Client then writes the block directly to the Data Node (usually TCP 50010). The receiving Data Node replicates the block to other Data Nodes, and the cycle repeats for the remaining blocks. The Name Node is not in the data path. The Name Node only provides the map of where data is and where data should go in the cluster (file system metadata).</p>
<p>Clientå°†File.txtæ‹†åˆ†ä¸º3ä¸ªå—ã€‚å¯¹æ¯ä¸ªå—ï¼ŒClientæŸ¥çœ‹Name Node(é€šå¸¸ç”¨TCP 9000)å¹¶æ¥æ”¶ä¸€ä¸ª3ä¸ªData Nodesçš„listï¼Œæ¯ä¸ªData Nodeéƒ½æ˜¯ä¸€ä¸ªå—çš„å¤åˆ¶ã€‚Clientå°†å—ç›´æ¥å†™å…¥åˆ°Data Node(é€šå¸¸ç”¨TCP 50010)ã€‚æ”¶åˆ°çš„Data Nodeå°†å—å¤åˆ¶åˆ°å…¶ä»–Data Nodesï¼Œå‰©ä¸‹çš„å—ä¹Ÿå¾ªç¯è¿™ä¸ªé‡å¤è¿‡ç¨‹ã€‚Name Nodeä¸æ˜¯æ•°æ®è·¯å¾„ã€‚åœ¨é›†ç¾¤ä¸­(æ–‡ä»¶ç³»ç»Ÿäº‘æ•°æ®)Name Nodeåªæä¾›æ•°æ®çš„ä½ç½®å’Œæ•°æ®åº”è¯¥å»å“ªã€‚</p>
<hr>
<p><img src="https://foreti.me/imgplace/2019/Hadoop-Rack-Awareness.png" alt="Hadoop-Rack-Awareness"></p>
<p>Hadoop has the concept of â€œRack Awarenessâ€. As the Hadoop administrator you can <strong>manually</strong> define the rack number of each slave Data Node in your cluster. Why would you go through the trouble of doing this? There are two key reasons for this: Data loss prevention, and network performance. Remember that each block of data will be replicated to multiple machines to prevent the failure of one machine from losing all copies of data. Wouldnâ€™t it be unfortunate if all copies of data happened to be located on machines in the same rack, and that rack experiences a failure? Such as a switch failure or power failure. That would be a mess. So to avoid this, somebody needs to know where Data Nodes are located in the network topology and use that information to make an intelligent decision about where data replicas should exist in the cluster. That â€œsomebodyâ€ is the Name Node.</p>
<p>Hadoopæœ‰â€œæœºæ¶æ„ŸçŸ¥â€çš„æ¦‚å¿µã€‚ä½œä¸ºHadoopç®¡ç†å‘˜ï¼Œä½ å¯ä»¥æ‰‹åŠ¨å®šä¹‰é›†ç¾¤ä¸­æ¯ä¸ªslave Data Nodedçš„æœºæ¶æ•°é‡ã€‚ä¸ºä»€ä¹ˆä½ è¦åšè¿™ä¸ªéº»çƒ¦çš„äº‹æƒ…å‘¢ï¼Ÿæœ‰ä¸¤ä¸ªå…³é”®åŸå› ï¼šé˜²æ­¢æ•°æ®ä¸¢å¤±å’Œç½‘ç»œæ€§èƒ½ã€‚è®°ä½æ¯ä¸ªå—çš„æ•°æ®éœ€è¦å¤åˆ¶åˆ°å¤šä¸ªæœºå™¨ä»¥é˜²æ­¢ä¸€ä¸ªæœºå™¨å¤±è´¥æ˜¯ä¸¢å¤±æ‰€æœ‰çš„æ•°æ®ã€‚å¦‚æœæ‰€æœ‰çš„æ•°æ®å¤åˆ¶ç¢°å·§ä½äºåŒæ„æœºæ¶çš„æœºå™¨ä¸Šï¼Œå¹¶ä¸”æœºæ¶å‘ç”Ÿå¤±è´¥ï¼Œä¼šå‘ç”Ÿè¿™æ ·çš„äº‹æƒ…å—ï¼Ÿæ¯”å¦‚ä¸€ä¸ªå¼€å…³å¤±è´¥æˆ–è€…æ˜¯ä¾›ç”µé—®é¢˜ã€‚é‚£å°†ä¼šä¸€å›¢ç³Ÿã€‚æ‰€ä»¥ä¸ºäº†é¿å…è¿™æ ·ï¼Œâ€œæŸç‰©â€éœ€è¦çŸ¥é“ç½‘ç»œæ‹“æ‰‘ä¸­Data Nodesåœ¨å“ªï¼Œä»¥æ­¤åšä¸€ä¸ªå…³äºæ•°æ®å¤åˆ¶å“åº”è¯¥å­˜æ”¾åœ¨é›†ç¾¤ä½•å¤„çš„æ™ºèƒ½çš„å†³å®šã€‚è¿™ä¸ªâ€œæŸç‰©â€æ˜¯Name Nodeã€‚</p>
<p>There is also an assumption that two machines in the same rack have more bandwidth and lower latency between each other than two machines in two different racks. This is true most of the time. The rack switch uplink bandwidth is usually (but not always) less than its downlink bandwidth. Furthermore, in-rack latency is usually lower than cross-rack latency (but not always). If at least one of those two basic assumptions are true, wouldnâ€™t it be cool if Hadoop can use the same Rack Awareness that protects data to also optimally place work streams in the cluster, improving network performance? Well, it does! Cool, right?</p>
<p>æœ‰ä¸€ä¸ªå‡è®¾å…³äºåœ¨åŒä¸€æœºæ¶çš„ä¸¤ä¸ªæœºå™¨ä¹‹é—´æ¯”èµ·ä¸åŒæœºæ¶çš„ä¸¤ä¸ªæœºå™¨æœ‰æ›´å¤šçš„å¸¦å®½å’Œæ›´ä½çš„ç­‰å¾…æ—¶é—´ã€‚å¤§å¤šæ˜¯æ—¶å€™è¿™æ˜¯æ­£ç¡®çš„ã€‚æœºæ¶å¼€å…³çš„ä¸Šè¡Œå¸¦å®½é€šå¸¸(ä¸æ€»æ˜¯)æ¯”ä¸‹è¡Œå¸¦å®½å°ã€‚è€Œä¸”ï¼Œåœ¨æœºæ¶å†…çš„ç­‰å¾…æ—¶é—´é€šå¸¸æ¯”æœºæ¶è§çš„ç­‰å¾…æ—¶é—´ä½(ä¸æ€»æ˜¯)ã€‚å¦‚æœè¿™ä¸¤ä¸ªåŸºç¡€å‡è®¾ä¸­è‡³å°‘ä¸€ä¸ªæ˜¯å¯¹çš„ï¼Œå¦‚æœHadoopèƒ½ç”¨åŒä¸€ä¸ªæœºæ¶æ„ŸçŸ¥ï¼Œä¿æŠ¤æ•°æ®åˆ°å·¥ä½œæµä¹Ÿå°±æ˜¯é›†ç¾¤ä¸­æœ€é€‚å®œçš„ä½ç½®ï¼Œæé«˜ç½‘ç»œæ€§èƒ½ï¼Œä¸ä¼šæ›´å¥½å—ï¼Ÿå½“ç„¶ä¼šã€‚</p>
<p>What is <strong>NOT</strong> cool about Rack Awareness at this point is the <a href="http://developer.yahoo.com/hadoop/tutorial/module2.html#rack">manual work required to define it the first time</a>, continually update it, and keep the information accurate. If the rack switch could auto-magically provide the Name Node with the list of Data Nodes it has, that would be cool. Or vice versa, if the Data Nodes could auto-magically tell the Name Node what switch theyâ€™re connected to, that would be cool too.</p>
<p>åœ¨è¿™ä¸€ç‚¹å…³äºæœºæ¶æ„ŸçŸ¥ä¸å¥½çš„åœ°æ–¹æ˜¯ï¼Œ<a href="http://developer.yahoo.com/hadoop/tutorial/module2.html#rack">manual work required to define it the first time</a>ï¼ŒæŒç»­çš„æ›´æ–°å®ƒï¼Œä¿æŒä¿¡æ¯å‡†ç¡®ã€‚å¦‚æœæœºæ¶å¯ä»¥è‡ªåŠ¨æä¾›Data Nodes listçš„Name Nodeï¼Œé‚£å°†ä¼šå¾ˆå¥½ã€‚åè¿‡æ¥ä¹Ÿæ˜¯ï¼Œå¦‚æœData Nodeså¯ä»¥è‡ªåŠ¨å‘Šè¯‰Name Nodeå®ƒä»¬è¿æ¥çš„ä»€ä¹ˆå¼€å…³ï¼Œä¹Ÿä¼šå¾ˆå¥½ã€‚</p>
<p>Even more interesting would be a <a href="http://www.bradhedlund.com/2011/04/21/data-center-scale-openflow-sdn/">OpenFlow network</a>, where the Name Node could query the OpenFlow controller about a Nodeâ€™s location in the topology.</p>
<p>ç”šè‡³æ›´æœ‰è¶£çš„æ˜¯ä¸€ä¸ª<a href="http://www.bradhedlund.com/2011/04/21/data-center-scale-openflow-sdn/">OpenFlow network</a>ï¼ŒName Nodeå¯ä»¥åœ¨å“ªæŸ¥è¯¢OpenFlowæ§åˆ¶å™¨å…³äºä¸€ä¸ªNodeçš„æ‹“æ‰‘ä½ç½®ã€‚</p>
<hr>
<p><img src="https://foreti.me/imgplace/2019/Preparing-HDFS-Writes.png" alt="Preparing-HDFS-Writes"></p>
<p>The Client is ready to load File.txt into the cluster and breaks it up into blocks, starting with Block A. The Client consults the Name Node that it wants to write File.txt, gets permission from the Name Node, and receives a list of (3) Data Nodes for each block, a unique list for each block. The Name Node used its Rack Awareness data to influence the decision of which Data Nodes to provide in these lists. The key rule is that <strong>for every block of data, two copies will exist in one rack, another copy in a different rack.</strong> So the list provided to the Client will follow this rule.</p>
<p>Clientå‡†å¤‡å¥½åŠ è½½æ–‡ä»¶åˆ°é›†ç¾¤ä¸­ï¼Œå°†å®ƒæ‰“æ–­åˆ°ä¸åŒçš„å—ï¼Œå¼€å§‹å—Aã€‚ClientæŸ¥è¯¢Name Nodeï¼Œæƒ³å†™å…¥File.txtï¼Œä»Name Nodeè·å–è®¸å¯ï¼Œæ¥æ”¶ä¸€ä¸ªåŒ…å«æ¯ä¸ªå—çš„Data Nodeçš„listï¼Œä¸€ä¸ªåŒ…å«æ¯ä¸ªå—ç‹¬æœ‰çš„listã€‚Name Nodeç”¨å®ƒçš„æœºæ¶æ„ŸçŸ¥æ•°æ®å»å½±å“è¿™äº›listä¸­æä¾›å“ªä¸ªData Nodesçš„å†³å®šã€‚é‡è¦è§„åˆ™æ˜¯<strong>å¯¹æ•°æ®çš„æ¯ä¸ªå—ï¼Œä¸¤ä¸ªå¤åˆ¶å­˜åœ¨ä¸€ä¸ªæœºæ¶ä¸­ï¼Œå¦ä¸€ä¸ªå¤åˆ¶åœ¨å…¶ä»–æœºæ¶ä¸­</strong>ã€‚æ‰€ä»¥è¿™ä¸ªlistæä¾›Clientå°†éµå¾ªè¿™ä¸ªè§„åˆ™ã€‚</p>
<p>Before the Client writes â€œBlock Aâ€ of File.txt to the cluster it wants to know that all Data Nodes which are expected to have a copy of this block are ready to receive it. It picks the first Data Node in the list for Block A (Data Node 1), opens a TCP 50010 connection and says, â€œHey, get ready to receive a block, and hereâ€™s a list of (2) Data Nodes, Data Node 5 and Data Node 6. Go make sure theyâ€™re ready to receive this block too.â€ Data Node 1 then opens a TCP connection to Data Node 5 and says, â€œHey, get ready to receive a block, and go make sure Data Node 6 is ready is receive this block too.â€ Data Node 5 will then ask Data Node 6, â€œHey, are you ready to receive a block?â€</p>
<p>åœ¨Clientå†™å…¥å—åˆ°File.txtä¹‹å‰ï¼Œå®ƒæƒ³çŸ¥é“æ‰€æœ‰çš„Data Nodeså“ªä¸ªæœŸæœ›å‡†å¤‡æ¥æ”¶ä¸€ä¸ªè¿™ä¸ªå—çš„å¤åˆ¶ã€‚å®ƒåœ¨listä¸­ä¸ºå—AæŒ‘é€‰ç¬¬ä¸€ä¸ªData Node(Data Node 1)ï¼Œæ‰“å¼€TCP 50010è¿æ¥ï¼Œç„¶åè¯´ï¼Œâ€œå˜¿ï¼Œå‡†å¤‡å¥½æ¥æ”¶ä¸€ä¸ªå—ï¼Œè¿™æ˜¯ä¸¤ä¸ªData Nodeçš„listï¼ŒData Node 5å’ŒData Node 6ã€‚å»ç¡®ä¿¡å®ƒä»¬ä¹Ÿå‡†å¤‡å¥½æ¥æ”¶è¿™ä¸ªå—ã€‚â€ç„¶åData Node 1æ‰“å¼€ä¸€ä¸ªTCPè¿æ¥åˆ°Data Node 5ç„¶åè¯´ï¼Œâ€œå˜¿ï¼Œå‡†å¤‡å¥½æ¥æ”¶ä¸€ä¸ªå—ï¼Œå»ç¡®ä¿¡Data Node 6ä¹Ÿå‡†å¤‡å¥½æ¥æ”¶è¿™ä¸ªå—ã€‚â€Data Node 5å°†é—®Data Node 6ï¼Œâ€œå˜¿ï¼Œä½ å‡†å¤‡å¥½æ¥æ”¶ä¸€ä¸ªå—äº†å—ï¼Ÿâ€</p>
<p>The acknowledgments of readiness come back on the same TCP pipeline, until the initial Data Node 1 sends a â€œReadyâ€ message back to the Client. At this point the Client is ready to begin writing block data into the cluster.</p>
<p>å‡†å¤‡å°±ç»ªçš„ç¡®è®¤é€šçŸ¥åœ¨åŒä¸€TCPç®¡é“è¿”å›ï¼Œç›´åˆ°åˆå§‹çš„Data Node 1å‘é€ä¸€ä¸ªâ€œReadyâ€ä¿¡æ¯ç»™Clientã€‚è¿™æ ·ï¼ŒClientå°±å‡†å¤‡å¥½å¼€å§‹å†™å…¥å—æ•°æ®åˆ°é›†ç¾¤ä¸­ã€‚</p>
<hr>
<p><img src="https://foreti.me/imgplace/2019/HDFS-Pipeline-Write.png" alt="HDFS-Pipeline-Write"></p>
<p>As data for each block is written into the cluster a replication pipeline is created between the (3) Data Nodes (or however many you have configured in dfs.replication). This means that as a Data Node is receiving block data it will at the same time push a copy of that data to the next Node in the pipeline.</p>
<p>å½“æ¯ä¸ªå—çš„æ•°æ®è¢«å†™å…¥é›†ç¾¤æ—¶, ä¸‰ä¸ªData Nodesä¹‹é—´(æˆ–è€…æ— è®ºå¤šå°‘ä¸ªä½ åœ¨dfs.replicationä¸­è®¾ç½®çš„)ä¼šåˆ›å»ºä¸€ä¸ªå¤åˆ¶ç®¡é“. è¿™æ„å‘³ç€, å½“ä¸€ä¸ªData Nodeæ¥æ”¶æ•°æ®å—æ—¶, å®ƒä¼šåŒæ—¶æ¨é€ä¸€ä¸ªæ•°æ®çš„å¤åˆ¶åˆ°ç®¡é“ä¸­çš„ä¸‹ä¸€ä¸ªNode.</p>
<p>Here too is a primary example of leveraging the Rack Awareness data in the Name Node to improve cluster performance. Notice that the second and third Data Nodes in the pipeline are in the same rack, and therefore the final leg of the pipeline does not need to traverse between racks and instead benefits from in-rack bandwidth and low latency. The next block will not be begin until this block is successfully written to all three nodes.</p>
<p>è¿™ä¹Ÿæ˜¯ä¸€ä¸ªå€ŸåŠ©æœºæ¶ç³»ç»Ÿçš„ç®€å•ä¾‹å­, Name Nodeä¸­çš„æ•°æ®æå‡é›†ç¾¤æ€§èƒ½. æ³¨æ„ç®¡é“ä¸­çš„ç¬¬äºŒä¸ªå’Œç¬¬ä¸‰ä¸ªData Nodeä½äºåŒä¸€ä¸ªæœºæ¶ä¸­, å› æ­¤ç®¡é“çš„æœ€åä¸€æ­¥ä¸ç”¨ç©¿è¿‡æœºæ¶, è¿™ä¼šå¸¦æ¥æœºæ¶å†…çš„å¸¦å®½å’Œä½å»¶è¿Ÿæ”¶ç›Š. ä¸‹ä¸€ä¸ªæ•°æ®å—ä¼šåœ¨è¿™ä¸€å—æˆåŠŸå†™å…¥åˆ°ä¸‰ä¸ªNodesåå¼€å§‹.</p>
<hr>
<p><img src="https://foreti.me/imgplace/2019/HDFS-Pipeline-Write-Success.png" alt="HDFS-Pipeline-Write-Success"></p>
<p>When all three Nodes have successfully received the block they will send a â€œBlock Receivedâ€ report to the Name Node. They will also send â€œSuccessâ€ messages back up the pipeline and close down the TCP sessions. The Client receives a success message and tells the Name Node the block was successfully written. The Name Node updates it metadata info with the Node locations of Block A in File.txt. The Client is ready to start the pipeline process again for the next block of data.</p>
<p>å½“æ‰€æœ‰çš„ä¸‰ä¸ªNodeéƒ½æˆåŠŸæ¥æ”¶äº†è¿™ä¸ªå—, å®ƒä»¬ä¼šå‘é€ä¸€ä¸ªâ€Block Receivedâ€æŠ¥å‘Šç»™Name Node. å®ƒä»¬ä¹Ÿä¼šç»™ç®¡é“è¿”å›ä¸€ä¸ªâ€Successâ€æ¶ˆæ¯å¹¶å…³é—­TCPåè®®. Clientæ¥æ”¶äº†ä¸€ä¸ªSuccessæ¶ˆæ¯, é€šçŸ¥Name Nodeå—å·²ç»æˆåŠŸå†™å…¥. Name Nodeæ›´æ–°File.txtä¸­å—Açš„Nodeä½ç½®çš„å…ƒæ•°æ®ä¿¡æ¯. Clientå‡†å¤‡å¥½å¼€å§‹ä¸‹ä¸€ä¸ªæ•°æ®å—çš„ç®¡é“å¤„ç†.</p>
<hr>
<p><img src="https://foreti.me/imgplace/2019/Multi-block-Replication-Pipeline.png" alt="Multi-block-Replication-Pipeline"></p>
<p>As the subsequent blocks of File.txt are written, the initial node in the pipeline will vary for each block, spreading around the hot spots of in-rack and cross-rack traffic for replication.</p>
<p>å½“File.txtä¸­éšåçš„å—éƒ½è¢«å†™å…¥, ç®¡é“ä¸­åˆå§‹çš„nodeä¼šä¸ºæ¯ä¸€ä¸ªå—åšç›¸åº”çš„å˜åŒ–, åœ¨æœºæ¶å†…çš„çƒ­ç‚¹é—´ä¼ æ’­, åœ¨æœºæ¶é—´å¤åˆ¶. </p>
<p>Hadoop uses a lot of network bandwidth and storage. We are typically dealing with very big files, Terabytes in size. And each file will be replicated onto the network and disk (3) times. If you have a 1TB file it will consume 3TB of network traffic to successfully load the file, and 3TB disk space to hold the file.</p>
<p>Hadoopä½¿ç”¨å¤§é‡çš„ç½‘ç»œå¸¦å®½å’Œå­˜å‚¨ç©ºé—´. ç‰¹åˆ«æ˜¯å½“æˆ‘ä»¬å¤„ç†éå¸¸å¤§çš„æ–‡ä»¶æ—¶, TBé‡çº§çš„. æ¯ä¸ªæ–‡ä»¶å°†3å€åœ°å¤åˆ¶åˆ°ç½‘ç»œå’Œç£ç›˜ä¸Š. å¦‚æœä½ æœ‰ä¸€ä¸ª1TBçš„æ–‡ä»¶, å®ƒå°†æ¶ˆè€—3TBçš„ç½‘ç»œæ¥æˆåŠŸåœ°åŠ è½½æ–‡ä»¶, ä»¥åŠ3TBçš„ç£ç›˜ç©ºé—´æ¥ä¿å­˜è¿™ä¸ªæ–‡ä»¶.</p>
<hr>
<p><img src="https://foreti.me/imgplace/2019/Client-Writes-Span-Cluster.png" alt="Client-Writes-Span-Cluster"></p>
<p>After the replication pipeline of each block is complete the file is successfully written to the cluster. As intended the file is spread in blocks across the cluster of machines, each machine having a relatively small part of the data. The more blocks that make up a file, the more machines the data can potentially spread. The more CPU cores and disk drives that have a piece of my data mean more parallel processing power and faster results. This is the motivation behind building large, wide clusters. To process more data, faster. When the machine count goes up and the cluster goes <strong>wide</strong>, our network needs to scale appropriately.</p>
<p>åœ¨æ¯ä¸ªå—çš„å¤åˆ¶ç®¡é“éƒ½å®Œæˆå, æ–‡ä»¶å°±æˆåŠŸåœ°å†™å…¥é›†ç¾¤äº†. ä¸ºäº†æ–‡ä»¶åœ¨é›†ç¾¤æœºå™¨çš„å—ä¹‹é—´ä¼ æ’­, æ¯ä¸ªæœºå™¨æœ‰ç›¸å¯¹å°çš„ä¸€éƒ¨åˆ†æ•°æ®. æ–‡ä»¶åˆ†å‰²çš„å—è¶Šå¤š, æ•°æ®å¯èƒ½ä¼ æ’­çš„æœºå™¨å°±è¶Šå¤š. ä¸€å—æ•°æ®æœ‰æ›´å¤šçš„CPUæ ¸å¿ƒå’Œç£ç›˜é©±åŠ¨æ„å‘³ç€æ›´å¥½çš„å¹¶è¡Œå¤„ç†èƒ½åŠ›å’Œæ›´å¿«çš„è·å¾—ç»“æœ. è¿™æ˜¯å»ºç«‹æ›´å¤§æ›´å®½çš„é›†ç¾¤çš„èƒŒåçš„åŠ¨æœº. ä¸ºäº†æ›´å¿«å¤„ç†æ›´å¤šçš„æ•°æ®. å½“æœºå™¨æ•°å¢é•¿, é›†ç¾¤å˜å®½, æˆ‘ä»¬çš„ç½‘ç»œéœ€è¦åˆé€‚çš„è§„æ¨¡.</p>
<p>Another approach to scaling the cluster is to go <strong>deep</strong>. This is where you scale up the machines with more disk drives and more CPU cores. Instead of increasing the number of machines you begin to look at increasing the density of each machine. In scaling deep, you put yourself on a trajectory where more network I/O requirements may be demanded of fewer machines. In this model, <a href="http://www.bradhedlund.com/2012/03/26/considering-10ge-hadoop-clusters-and-the-network/">how your Hadoop cluster makes the transition to 10GE nodes</a> becomes an important consideration.</p>
<p>çºµå‘å‘å±•æ˜¯è§„æ¨¡åŒ–é›†ç¾¤çš„å¦ä¸€ç§æ–¹æ³•. è¿™å³æ˜¯ä½ ç”¨æ›´å¤šçš„ç£ç›˜é©±åŠ¨å’Œæ›´å¤šçš„CPUæ ¸æ•°çºµå‘æ‰©å±•æœºå™¨. ç›¸å¯¹å¢åŠ æœºå™¨æ•°é‡, å–è€Œä»£ä¹‹çš„æ˜¯å¢åŠ æ¯ä¸ªæœºå™¨çš„å¯†åº¦. åœ¨çºµå‘åŒ–æ—¶, ä½ å°†è¶‹å‘äºæ›´å¤šçš„ç½‘ç»œI/Oéœ€æ±‚ä½¿ç”¨æ›´å°‘çš„æœºå™¨. åœ¨è¿™ç§æ¨¡å¼ä¸‹, ä½ çš„Hasoopé›†ç¾¤æ€æ ·å˜è¿åˆ°10GE nodesæˆä¸ºä¸€ä¸ªé‡ç‚¹.</p>
<hr>
<p><img src="https://foreti.me/imgplace/2019/Name-Node.png" alt="Name-Node"></p>
<p>The Name Node holds all the file system metadata for the cluster and oversees the health of Data Nodes and coordinates access to data. The Name Node is the central controller of HDFS. It does not hold any cluster data itself. The Name Node only knows what blocks make up a file and where those blocks are located in the cluster. The Name Node points Clients to the Data Nodes they need to talk to and keeps track of the clusterâ€™s storage capacity, the health of each Data Node, and making sure each block of data is meeting the minimum defined replica policy.</p>
<p>Name Nodeæ§åˆ¶é›†ç¾¤çš„æ‰€æœ‰çš„æ–‡ä»¶ç³»ç»Ÿå…ƒæ•°æ®, ç›‘ç£Data Nodesçš„å¥åº·å’Œåè°ƒæ•°æ®å…¥å£. Name Nodeæ—¶HDFSçš„æ§åˆ¶ä¸­å¿ƒ. å®ƒè‡ªå·±ä¸æ§åˆ¶ä»»ä½•é›†ç¾¤æ•°æ®. Name NodeåªçŸ¥é“æ–‡ä»¶ç”±ä»€ä¹ˆå—ç»„æˆ, å’Œé‚£äº›å—åœ¨é›†ç¾¤ä¸­çš„ä½ç½®. Name Nodeä»ClientæŒ‡å‘Data Nodes, å®ƒä»¬éœ€è¦äº¤æµæ¥ä¿æŒé›†ç¾¤å­˜å‚¨èƒ½åŠ›å’Œæ¯ä¸ªData Nodeå¥åº·çš„è½¨è¿¹, å¹¶ä¸”ç¡®è®¤æ¯ä¸ªæ•°æ®çš„å—ä¿è¯æœ€ä½é™åº¦çš„å¤åˆ¶.</p>
<p>Data Nodes send heartbeats to the Name Node every 3 seconds via a TCP handshake, using the same port number defined for the Name Node daemon, usually TCP 9000. Every tenth heartbeat is a Block Report, where the Data Node tells the Name Node about all the blocks it has. The block reports allow the Name Node build its metadata and insure (3) copies of the block exist on different nodes, in different racks.</p>
<p>Data Nodeé€šè¿‡TCPæ¡æ‰‹æ¯3ç§’å‘é€å¿ƒè·³ç»™Name Node, ä¸ºName Nodeä½¿ç”¨åŒä¸€ä¸ªç¡®å®šçš„ç«¯å£å·, é€šå¸¸æ˜¯TCP 9000. æ¯ç¬¬10ä¸ªå¿ƒè·³æ˜¯ä¸€ä¸ªå—æŠ¥å‘Š, å…³äºData Nodeå‘Šè¯‰Name Nodeæ‰€æœ‰å®ƒæœ‰çš„å—. å—æŠ¥å‘Šå…è®¸Name Nodeå»ºç«‹å®ƒçš„å…ƒæ•°æ®å’Œç¡®è®¤å—çš„3ä¸ªå¤åˆ¶å­˜åœ¨äºä¸åŒæœºæ¶çš„ä¸åŒçš„nodeä¸Š.</p>
<p>The Name Node is a critical component of the Hadoop Distributed File System (HDFS). Without it, Clients would not be able to write or read files from HDFS, and it would be impossible to schedule and execute Map Reduce jobs. Because of this, itâ€™s a good idea to equip the Name Node with a highly redundant enterprise class server configuration; dual power supplies, hot swappable fans, redundant NIC connections, etc.</p>
<p>Name Nodeæ˜¯Hadoopåˆ†å¸ƒå¼æ–‡ä»¶ç³»ç»Ÿçš„ä¸€ä¸ªå…³é”®çš„ç»„ä»¶. æ²¡æœ‰å®ƒ, Clientså°†ä¸èƒ½ä»HDFSå†™å’Œè¯»æ–‡ä»¶, è€Œä¸”ä¹Ÿä¸èƒ½è§„åˆ’å’Œæ‰§è¡ŒMap Reduceå·¥ä½œ. å½’åŠŸäºå®ƒ, ç”¨é«˜å†—ä½™ä¼ä¸šç±»æœåŠ¡å™¨é…ç½®å®‰è£…Name Nodeæ˜¯ä¸€ä¸ªå¥½ä¸»æ„. åŒé‡æ”¯æŒ, çƒ­äº¤æ¢, å†—ä½™NICè¿æ¥, ç­‰.</p>
<hr>
<p><img src="https://foreti.me/imgplace/2019/Re-replicating-Missing-Replicas2.png" alt="Re-replicating-Missing-Replicas2"></p>
<p>If the Name Node stops receiving heartbeats from a Data Node it presumes it to be dead and any data it had to be gone as well. Based on the block reports it had been receiving from the dead node, the Name Node knows which copies of blocks died along with the node and can make the decision to re-replicate those blocks to other Data Nodes. It will also consult the Rack Awareness data in order to maintain the <strong>two copies in one rack, one copy in another rack</strong> replica rule when deciding which Data Node should receive a new copy of the blocks.</p>
<p>Consider the scenario where an entire rack of servers falls off the network, perhaps because of a rack switch failure, or power failure. The Name Node would begin instructing the remaining nodes in the cluster to re-replicate all of the data blocks lost in that rack. If each server in that rack had a modest 12TB of data, this could be hundreds of terabytes of data that needs to begin traversing the network.</p>
<hr>
<p><img src="https://foreti.me/imgplace/2019/Secondary-Name-Node.png" alt="Secondary-Name-Node"></p>
<p>Hadoop has server role called the Secondary Name Node. A common misconception is that this role provides a high availability backup for the Name Node. This is not the case.</p>
<p>The Secondary Name Node occasionally connects to the Name Node (by default, ever hour) and grabs a copy of the Name Nodeâ€™s in-memory metadata and files used to store metadata (both of which may be out of sync). The Secondary Name Node combines this information in a fresh set of files and delivers them back to the Name Node, while keeping a copy for itself.</p>
<p>Should the Name Node die, the files retained by the Secondary Name Node can be used to recover the Name Node. In a busy cluster, the administrator may configure the Secondary Name Node to provide this housekeeping service much more frequently than the default setting of one hour. Maybe every minute.</p>
<hr>
<p><img src="https://foreti.me/imgplace/2019/Client-Read-from-HDFS.png" alt="Client-Read-from-HDFS"></p>
<p>When a Client wants to retrieve a file from HDFS, perhaps the output of a job, it again consults the Name Node and asks for the block locations of the file. The Name Node returns a list of each Data Node holding a block, for each block. The Client picks a Data Node from each block list and reads one block at a time with TCP on port 50010, the default port number for the Data Node daemon. It does not progress to the next block until the previous block completes.</p>
<hr>
<p><img src="https://foreti.me/imgplace/2019/Data-Node-Read-from-HDFS.png" alt="Data-Node-Read-from-HDFS"></p>
<p>There are some cases in which a Data Node daemon itself will need to read a block of data from HDFS. One such case is where the Data Node has been asked to process data that it does not have locally, and therefore it must retrieve the data from another Data Node over the network before it can begin processing.</p>
<p>This is another key example of the Name Nodeâ€™s Rack Awareness knowledge providing optimal network behavior. When the Data Node asks the Name Node for location of block data, the Name Node will check if another Data Node in the same rack has the data. If so, the Name Node provides the in-rack location from which to retrieve the data. The flow does not need to traverse two more switches and congested links find the data in another rack. With the data retrieved quicker in-rack, the data processing can begin sooner, and the job completes that much faster.</p>
<hr>
<p><img src="https://foreti.me/imgplace/2019/Map-Task.png" alt="Map-Task"></p>
<p>Now that File.txt is spread in small blocks across my cluster of machines I have the opportunity to provide extremely fast and efficient parallel processing of that data. The parallel processing framework included with Hadoop is called Map Reduce, named after two important steps in the model; <strong>Map</strong>, and <strong>Reduce</strong>.</p>
<p>The first step is the Map process. This is where we simultaneously ask our machines to run a computation on their local block of data. In this case we are asking our machines to count the number of occurrences of the word â€œRefundâ€ in the data blocks of File.txt.</p>
<p>To start this process the Client machine submits the Map Reduce job to the Job Tracker, asking â€œHow many times does Refund occur in File.txtâ€ (paraphrasing Java code). The Job Tracker consults the Name Node to learn which Data Nodes have blocks of File.txt. The Job Tracker then provides the Task Tracker running on those nodes with the Java code required to execute the Map computation on their local data. The Task Tracker starts a Map task and monitors the tasks progress. The Task Tracker provides heartbeats and task status back to the Job Tracker.</p>
<p>As each Map task completes, each node stores the result of its local computation in temporary local storage. This is called the â€œintermediate dataâ€. The next step will be to send this intermediate data over the network to a Node running a Reduce task for final computation.</p>
<hr>
<p><img src="https://foreti.me/imgplace/2019/What-if-Map-Task-data-isnt-local.png" alt="What-if-Map-Task-data-isnt-local"></p>
<p>While the Job Tracker will always try to pick nodes with local data for a Map task, it may not always be able to do so. One reason for this might be that all of the nodes with local data already have too many other tasks running and cannot accept anymore. In this case, the Job Tracker will consult the Name Node whose Rack Awareness knowledge can suggest other nodes in the same rack. The Job Tracker will assign the task to a node in the same rack, and when that node goes to find the data it needs the Name Node will instruct it to grab the data from another node in its rack, leveraging the presumed single hop and high bandwidth of in-rack switching.</p>
<hr>
<p><img src="https://foreti.me/imgplace/2019/Reduce-Task.png" alt="Reduce-Task"></p>
<p>The second phase of the Map Reduce framework is called, you guess it, <strong>Reduce</strong>. The Map task on the machines have completed and generated their intermediate data. Now we need to gather all of this intermediate data to combine and distill it for further processing such that we have one final result.</p>
<p>The Job Tracker starts a Reduce task on any one of the nodes in the cluster and instructs the Reduce task to go grab the intermediate data from all of the completed Map tasks. The Map tasks may respond to the Reducer almost simultaneously, resulting in a situation where you have a number of nodes sending TCP data to a single node, all at once. This traffic condition is often referred to as <a href="http://www.bradhedlund.com/2011/05/01/tcp-incast-and-cloud-application-performance/">TCP Incast</a> or â€œfan-inâ€. For networks handling lots of Incast conditions, itâ€™s important the network switches have well-engineered internal traffic management capabilities, and adequate buffers (not too big, not too small). Throwing gobs of buffers at a switch may end up causing unwanted collateral damage to other traffic. But thatâ€™s a topic for another day.</p>
<p>The Reducer task has now collected all of the intermediate data from the Map tasks and can begin the final computation phase. In this case, we are simply adding up the sum total occurrences of the word â€œRefundâ€ and writing the result to a file called Results.txt</p>
<p>The output from the job is a file called Results.txt that is written to HDFS following all of the processes we have covered already; splitting the file up into blocks, pipeline replication of those blocks, etc. When complete, the Client machine can read the Results.txt file from HDFS, and the job is considered complete.</p>
<p>Our simple word count job did not result in a lot of intermediate data to transfer over the network. Other jobs however may produce a lot of intermediate data â€“ such as sorting a terabyte of data. Where the output of the Map Reduce job is a new set of data equal to the size of data you started with. How much traffic you see on the network in the Map Reduce process is entirely dependent on the type job you are running at that given time.</p>
<p>If youâ€™re a studious network administrator, you would learn more about Map Reduce and the types of jobs your cluster will be running, and how the type of job affects the traffic flows on your network. If youâ€™re a Hadoop networking rock star, you might even be able to suggest ways to better code the Map Reduce jobs so as to optimize the performance of the network, resulting in faster job completion times.</p>
<hr>
<p><img src="https://foreti.me/imgplace/2019/Unbalanced-Hadoop-Cluster.png" alt="Unbalanced-Hadoop-Cluster"></p>
<p>Hadoop may start to be a real success in your organization, providing a lot of previously untapped business value from all that data sitting around. When business folks find out about this you can bet that youâ€™ll quickly have more money to buy more racks of servers and network for your Hadoop cluster.</p>
<p>When you add new racks full of servers and network to an existing Hadoop cluster you can end up in a situation where your cluster is unbalanced. In this case, Racks 1 &amp; 2 were my existing racks containing File.txt and running my Map Reduce jobs on that data. When I added two new racks to the cluster, my File.txt data doesnâ€™t auto-magically start spreading over to the new racks. All the data stays where it is.</p>
<p>The new servers are sitting idle with no data, until I start loading new data into the cluster. Furthermore, if the servers in Racks 1 &amp; 2 are really busy, the Job Tracker may have no other choice but to assign Map tasks on File.txt to the new servers which have no local data. The new servers need to go grab the data over the network. As as result you may see more network traffic and slower job completion times.</p>
<hr>
<p><img src="https://foreti.me/imgplace/2019/Hadoop-Cluster-Balancer.png" alt="Hadoop-Cluster-Balancer"></p>
<p>To fix the unbalanced cluster situation, Hadoop includes a nifty utility called, you guessed it, <strong>balancer</strong>.</p>
<p>Balancer looks at the difference in available storage between nodes and attempts to provide balance to a certain threshold. New nodes with lots of free disk space will be detected and balancer can begin copying block data off nodes with less available space to the new nodes. Balancer isnâ€™t running until someone types the command at a terminal, and it stops when the terminal is canceled or closed.</p>
<p>The amount of network traffic balancer can use is very low, with a default setting of 1MB/s. This setting can be changed with the <strong>dfs.balance.bandwidthPerSec</strong> parameter in the file <strong>hdfs-site.xml</strong></p>
<p>The Balancer is good housekeeping for your cluster. It should definitely be used any time new machines are added, and perhaps even run once a week for good measure. Given the balancers low default bandwidth setting it can take a long time to finish its work, perhaps days or weeks. Wouldnâ€™t it be cool if cluster balancing was a core part of Hadoop, and not just a utility? I think so.</p>
<hr>
<p>This material is based on studies, <a href="http://www.cloudera.com/hadoop-training/">training from Cloudera</a>, and observations from my own virtual Hadoop lab of six nodes. Everything discussed here is based on the <a href="https://ccp.cloudera.com/display/SUPPORT/Downloads">latest stable release of Clouderaâ€™s CDH3 distribution of Hadoop</a>. There are new and interesting technologies coming to Hadoop such as <a href="http://hadoop.apache.org/common/docs/r0.21.0/hod_scheduler.html#Introduction">Hadoop on Demand (HOD)</a> and <a href="http://www.hortonworks.com/an-introduction-to-hdfs-federation/">HDFS Federations</a>, not discussed here, but worth investigating on your own if so inclined.</p>
<p><strong>Download:</strong> <a href="http://pic.yanss.top/Understanding_Hadoop_Clusters_and_the_Network-bradhedlund_com.pdf">Slides - PDF</a> <a href="http://pic.yanss.top/Understanding_Hadoop_Clusters_and_the_Network-slides_and_text_bradhedlund_com.pdf">Slides and Text - PDF</a></p>
<p>Cheers, Brad</p>


                            <!-- Meta -->
                            <div class="post-meta">
                                <hr>
                                <br>
                                <div class="post-tags">
                                    
                                        

<a href="/blog/tags/hadoop/">#hadoop</a>


                                            
                                </div>
                                <div class="post-date">
                                    
                                        2018 å¹´ 02 æœˆ 10 æ—¥
                                    
                                </div>
                            </div>
                    </div>

                    <!-- Comments -->
                    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                        <!-- Disqus Comments -->

<div id="disqus_thread" class="comment"></div>
  <!--<script>
    var disqus_shortname = 'you-yue-ru-tie';
    var disqus_website = '/';
    var disqus_config = function () {
      this.page.url = disqus_website;
      this.page.identifier = disqus_shortname;
    };
    (function () {
      var d = document, s = d.createElement('script');
      s.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by
      Disqus.</a></noscript>-->
  <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'you-yue-ru-tie';
  
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>


                    </div>
                </div>
            </div>
        </article>
</section>

<!-- Image viewer-->

    <!-- Custom picture view-->
    <link href="/blog/css/viewer.min.css" rel="stylesheet" />
    <script
      src="/blog/js/viewer.min.js"
      type="text/javascript"
      charset="utf-8"
    ></script>
    
    <script type="text/javascript">
      // set image viewer
      Viewer.setDefaults({
        zoomRatio: [0.5],
        navbar: false,
        toolbar: false,
        button: false,
        title: [2, (image, imageData) => `${image.alt}`],
        show: function() {
          this.viewer.zoomTo(0.5);
        }
      });
      var imageList = document.getElementsByTagName("img");
      Array.prototype.forEach.call(imageList, element => {
        var viewer = new Viewer(element);
      });
    </script>

    

<!-- TOC -->

    <aside id="article-toc" role="navigation" class="fixed">
        <div id="article-toc-inner">
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Understanding-Hadoop-Clusters-and-the-Network"><span class="toc-text">Understanding Hadoop Clusters and the Network</span></a></li></ol>
        </div>
    </aside>

    <!-- Scripts -->
    <script type="text/javascript">
    console.log("Â© zchen9 ğŸ™‹ 2015-" + new Date().getFullYear());
</script>
  
    <!-- Google Analytics -->
    
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-112380656-1', 'auto');
        ga('send', 'pageview');

    </script>


    <!-- Service Worker -->
    <!-- if using service worker -->

    <script text="module">
      if ("serviceWorker" in navigator) {
        navigator.serviceWorker
          .register("/blog/js/sw.js")
          .then(function() {
            console.log("A new service worker is being installed.");
          })
          .catch(function(error) {
            console.log("Service worker registration failed:", error);
          });
      } else {
        console.log("Service workers are not supported.");
      }
    </script>

    
</body>

</html>